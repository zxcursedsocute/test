
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- == КОНФИГУРАЦИЯ ==
local AbilityStats = {
    ["MassInfection"] = { 
        Speed = 80,
        Windup = 0.6
    },
    ["Entanglement"] = { 
        Speed = 120,
        Windup = 0.45
    }
}

local Settings = {
    FOV = 800,
    PredictionMult = 1.05,
    Smoothness = 0.2
}

-- == ПЕРЕМЕННЫЕ АИМА ==
local IsAiming = false
local AimEndTime = 0
local CurrentTarget = nil
local CurrentSpeed = 0

-- == ФУНКЦИИ ПОИСКА ==
local function IsValid(player)
    if not player or player == LocalPlayer then return false end
    local char = player.Character
    if not char then return false end
    local root = char:FindFirstChild("HumanoidRootPart")
    local human = char:FindFirstChild("Humanoid")
    if not root or not human or human.Health <= 0 then return false end
    return true
end

local function GetClosestTarget()
    local closest = nil
    local maxDist = Settings.FOV
    local mousePos = UserInputService:GetMouseLocation()

    for _, v in pairs(Players:GetPlayers()) do
        if IsValid(v) then
            local root = v.Character.HumanoidRootPart
            -- Проверяем видимость
            local pos, visible = Camera:WorldToViewportPoint(root.Position)
            if visible then
                local dist = (Vector2.new(mousePos.X, mousePos.Y) - Vector2.new(pos.X, pos.Y)).Magnitude
                if dist < maxDist then
                    maxDist = dist
                    closest = v
                end
            end
        end
    end
    return closest
end

local function PredictPosition(target, speed)
    if not target or not target.Character then return Vector3.zero end
    local root = target.Character:FindFirstChild("HumanoidRootPart")
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root or not myRoot then return Vector3.zero end
    
    local dist = (root.Position - myRoot.Position).Magnitude
    local timeToHit = dist / speed
    
    local velocity = root.AssemblyLinearVelocity or Vector3.zero
    return root.Position + (velocity * timeToHit * Settings.PredictionMult)
end

-- == ХУК МОДУЛЯ ==
local function InitKillerHook()
    if getgenv().KillerHookLoaded then return end

    -- Поиск модуля поведения киллера
    local modulePath = nil
    local success, err = pcall(function()
        local killerFolder = ReplicatedStorage:FindFirstChild("Assets")
            and ReplicatedStorage.Assets:FindFirstChild("Killers")
        if not killerFolder then return end
        
        local killer = killerFolder:FindFirstChild("1x1x1x1") 
                   or killerFolder:FindFirstChild("TheGlitch")
        if killer and killer:FindFirstChild("Behavior") then
            modulePath = require(killer.Behavior)
        end
    end)

    if not modulePath then
        warn("Аимбот: Не удалось найти модуль киллера. Путь: ReplicatedStorage.Assets.Killers.[1x1x1x1/TheGlitch].Behavior")
        return
    end

    print("Аимбот: Модуль найден, устанавливаем хуки...")

    for abilityName, stats in pairs(AbilityStats) do
        -- Защита от отсутствия таблицы способностей
        if not modulePath.Abilities then
            warn("Аимбот: В модуле нет поля Abilities")
            break
        end
        
        local abilityTable = modulePath.Abilities[abilityName]
        if abilityTable and type(abilityTable.Callback) == "function" then
            print("Хукаем способность: " .. abilityName)
            
            local oldFunc = abilityTable.Callback
            
            -- Новая функция-хук с обработкой ошибок
            abilityTable.Callback = function(...)
                -- Ловиим ошибки внутри хука
                local hookSuccess, hookResult = pcall(function()
                    print("[AIMBOT] Активация: " .. abilityName)
                    
                    local target = GetClosestTarget()
                    if target then
                        CurrentTarget = target
                        CurrentSpeed = stats.Speed
                        AimEndTime = tick() + stats.Windup
                        IsAiming = true
                        print("Цель захвачена: " .. target.Name)
                    end
                    
                    -- Вызываем оригинальную функцию с теми же аргументами
                    return oldFunc(...)
                end)
                
                if not hookSuccess then
                    warn("[AIMBOT] Ошибка в хуке: " .. tostring(hookResult))
                    -- Если ошибка, всё равно вызываем оригинал без нашей логики
                    return oldFunc(...)
                end
                return hookResult
            end
        else
            warn("Способность не найдена или Callback не функция: " .. abilityName)
        end
    end

    getgenv().KillerHookLoaded = true
    print("Аимбот: Все хуки успешно установлены!")
end

-- == ЦИКЛ АИМА ==
RunService.RenderStepped:Connect(function()
    if IsAiming and CurrentTarget and IsValid(CurrentTarget) then
        if tick() > AimEndTime then
            IsAiming = false
            CurrentTarget = nil
            return
        end

        local predictedPos = PredictPosition(CurrentTarget, CurrentSpeed)
        if predictedPos == Vector3.zero then return end
        
        local currentCF = Camera.CFrame
        local targetCF = CFrame.new(currentCF.Position, predictedPos)
        Camera.CFrame = currentCF:Lerp(targetCF, Settings.Smoothness)
    else
        IsAiming = false
    end
end)

-- Запуск
if not game:IsLoaded() then game.Loaded:Wait() end
InitKillerHook()

-- Перехват респавна
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    getgenv().KillerHookLoaded = false
    InitKillerHook()
end)
